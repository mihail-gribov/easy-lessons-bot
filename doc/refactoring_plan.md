# План рефакторинга Easy Lessons Bot

## Обзор

Данный документ содержит план рефакторинга кода проекта Easy Lessons Bot на основе проведенного анализа архитектуры и качества кода. План направлен на устранение критических проблем дублирования, упрощение сложных компонентов и улучшение поддерживаемости кода.

## Критерии готовности каждой итерации
- Код компилируется без ошибок
- Все тесты проходят
- Функционал можно протестировать вручную
- Логирование работает корректно
- Соблюдены принципы KISS и YAGNI

---

## Итерация 1: Унификация пайплайнов обработки сообщений

**Цель**: Устранить дублирование логики между текстовым и медиа пайплайнами

### Этап 1: Создание единого процессора сообщений
- [ ] Создать `core/message_processor.py` с классом `UnifiedMessageProcessor`
- [ ] Реализовать метод `process_message(message, message_type)` для обработки всех типов сообщений
- [ ] Добавить метод `_create_synthetic_message(transcript, original_message)` для создания синтетических сообщений из транскриптов
- [ ] Протестировать создание синтетических сообщений

### Этап 2: Модификация обработчиков
- [ ] Изменить `handle_voice_message()` в `bot/handlers.py` для использования единого пайплайна
- [ ] Убрать дублирующую логику анализа намерений из `bot/media_handlers.py`
- [ ] Обновить логирование для единообразия между пайплайнами
- [ ] Протестировать, что аудио и текст дают одинаковые результаты

### Этап 3: Очистка медиа-пайплайна
- [ ] Удалить неиспользуемые методы из `MediaHandlers`
- [ ] Упростить `MediaProcessor` до простого транскриптора
- [ ] Обновить тесты для работы с единым пайплайном
- [ ] Проверить отсутствие регрессий

---

## Итерация 2: Рефакторинг системы синглтонов

**Цель**: Заменить глобальные синглтоны на централизованный DI контейнер

### Этап 1: Создание DI контейнера
- [ ] Создать `core/di_container.py` с классом `ServiceContainer`
- [ ] Реализовать методы `register()`, `get()`, `is_registered()`
- [ ] Добавить поддержку lazy initialization
- [ ] Протестировать базовую функциональность контейнера

### Этап 2: Миграция сервисов
- [ ] Зарегистрировать `LLMClient` в контейнере
- [ ] Зарегистрировать `SessionManager` в контейнере
- [ ] Зарегистрировать `PromptStore` в контейнере
- [ ] Зарегистрировать `DatabaseManager` в контейнере
- [ ] Протестировать работу через контейнер

### Этап 3: Обновление зависимостей
- [ ] Заменить все `get_*_client()` вызовы на `container.get()`
- [ ] Убрать глобальные переменные из всех модулей
- [ ] Обновить `app/main.py` для инициализации контейнера
- [ ] Протестировать полную функциональность

---

## Итерация 3: Разделение монолитных классов

**Цель**: Разделить сложные классы на более простые и специализированные

### Этап 1: Рефакторинг PromptStore
- [ ] Создать `core/prompts/prompt_loader.py` с классом `PromptLoader`
- [ ] Создать `core/context/context_analyzer.py` с классом `ContextAnalyzer`
- [ ] Создать `core/dialog/dialog_builder.py` с классом `DialogBuilder`
- [ ] Перенести соответствующие методы из `PromptStore`
- [ ] Протестировать каждый новый класс отдельно

### Этап 2: Рефакторинг репозиториев
- [ ] Создать `core/persistence/base_repository.py` с базовым классом `BaseRepository`
- [ ] Вынести общие CRUD операции в базовый класс
- [ ] Упростить `SessionRepository`, `MessageRepository`, `MediaFileRepository`
- [ ] Протестировать все репозитории

### Этап 3: Упрощение обработчиков
- [ ] Разделить `handle_text_message()` на более мелкие функции
- [ ] Создать `_get_session_context()`, `_analyze_message()`, `_generate_response()`
- [ ] Упростить логику обработки ошибок
- [ ] Протестировать упрощенные обработчики

---

## Итерация 4: Упрощение обработки ошибок в LLM клиенте

**Цель**: Упростить сложную логику retry и обработки ошибок

### Этап 1: Создание стратегии retry
- [ ] Создать `core/retry/retry_strategy.py` с классом `RetryStrategy`
- [ ] Реализовать методы `should_retry()`, `get_delay()`, `is_retryable_error()`
- [ ] Добавить конфигурацию retry через настройки
- [ ] Протестировать стратегию retry

### Этап 2: Рефакторинг LLM клиента
- [ ] Упростить метод `generate_response()` используя `RetryStrategy`
- [ ] Убрать вложенные try-catch блоки
- [ ] Создать отдельные методы для каждого типа ошибки
- [ ] Протестировать упрощенный клиент

### Этап 3: Унификация обработки ошибок
- [ ] Создать `core/errors/error_handler.py` для централизованной обработки
- [ ] Стандартизировать логирование ошибок
- [ ] Обновить graceful degradation для использования нового обработчика
- [ ] Протестировать обработку всех типов ошибок

---

## Итерация 5: Оптимизация производительности

**Цель**: Улучшить производительность критических компонентов

### Этап 1: Оптимизация работы с БД
- [ ] Реализовать пул соединений в `DatabaseManager`
- [ ] Добавить переиспользование сессий для коротких операций
- [ ] Оптимизировать запросы в репозиториях
- [ ] Протестировать производительность БД

### Этап 2: Кеширование LLM результатов
- [ ] Создать `core/cache/llm_cache.py` с кешированием результатов auxiliary model
- [ ] Добавить TTL для кешированных результатов
- [ ] Интегрировать кеш в `ContextAnalyzer`
- [ ] Протестировать кеширование

### Этап 3: Оптимизация конфигурации
- [ ] Вынести все магические числа в `core/constants.py`
- [ ] Централизовать настройки медиа в одном месте
- [ ] Добавить валидацию конфигурации при старте
- [ ] Протестировать новую конфигурацию

---

## Итерация 6: Финальная очистка и тестирование

**Цель**: Завершить рефакторинг и обеспечить стабильность

### Этап 1: Очистка кода
- [ ] Убрать все циклические импорты
- [ ] Стандартизировать форматирование кода
- [ ] Добавить недостающие типы и docstrings
- [ ] Запустить полную проверку линтера

### Этап 2: Обновление тестов
- [ ] Обновить все тесты для работы с новой архитектурой
- [ ] Добавить тесты для новых компонентов
- [ ] Проверить покрытие тестами критических путей
- [ ] Запустить полный набор тестов

### Этап 3: Документация и финализация
- [ ] Обновить README.md с новой архитектурой
- [ ] Создать диаграмму архитектуры
- [ ] Обновить документацию API
- [ ] Провести финальное тестирование всех функций

---

## Метрики успеха

### Функциональные метрики
- [ ] Все существующие тесты проходят
- [ ] Аудио и текст дают идентичные результаты
- [ ] Время обработки не увеличилось более чем на 10%
- [ ] Отсутствие регрессий в функциональности

### Архитектурные метрики
- [ ] Уменьшение дублирования кода на 50%+
- [ ] Упрощение сложных функций (снижение цикломатической сложности)
- [ ] Единообразное логирование всех операций
- [ ] Устранение всех глобальных синглтонов

### Качественные метрики
- [ ] Улучшение читаемости кода
- [ ] Упрощение добавления новых функций
- [ ] Снижение времени на понимание архитектуры
- [ ] Повышение надежности системы

---

## Риски и митигация

### Риски
1. **Регрессии**: Изменение поведения существующих функций
2. **Производительность**: Временное снижение производительности во время рефакторинга
3. **Сложность**: Усложнение кода при неправильном разделении ответственности

### Митигация
1. **Тестирование**: Comprehensive testing на каждом этапе
2. **Постепенная миграция**: Поэтапное внедрение изменений
3. **Мониторинг**: Тщательное отслеживание производительности
4. **Откат**: Возможность быстрого отката к предыдущей версии

---

## Заключение

Данный план рефакторинга направлен на устранение критических архитектурных проблем проекта Easy Lessons Bot. Реализация плана обеспечит:

- **Устранение дублирования** между пайплайнами обработки сообщений
- **Упрощение архитектуры** через централизованное управление зависимостями
- **Повышение поддерживаемости** через разделение сложных компонентов
- **Улучшение производительности** через оптимизацию критических путей

План рассчитан на 6 итераций с четкими критериями готовности и метриками успеха для каждой итерации.
